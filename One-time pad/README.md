# One-Time Pad
This cipher is one of the simplest and easiest to understand.

If correctly used, is the most secure known cipher, meaning that no information about the plaintext can be gathered by simply looking at the ciphertext.

However, since it requires that:
1. the key's length must be the same size as the plaintext length (implementation requirement);
2. the key must be random (security requirement), and
3. the key used to encrypt one plaintext must never be used to encrypt another (security requirement),

it's an unpractical cipher to use in most modern applications.

Here, we explore the vulnerability created by breaking the third rule above. In this scenario, since the same key was used to encrypt multiple messages,
we can gather information about the messages that wouldn't be possible otherwise.

This attack is sometimes called the "Many-Time Pad attack", since the name "**One-Time** Pad" implies that an one-time (unique) key is used.

## Encrypting messages - One-Time Pad
Write, inside the `plaintexts.txt` file, a list of messages that you want to encrypt, separated by line breaks, then run the `otp_encrypt.py` script.
A number of unique pseudorandom keys will be generated by the script and each will be used to encrypt a single message, the resulting keys and ciphertexts will
be available inside the `keys.txt` and `ciphertexts.txt` files, respectively, both encoded in hexadecimal.

## Encrypting messages - Many-Time Pad
Using the same file `plaintexts.txt` containing the messages to be encrypted, this time run the `mtp_encrypt.py` script. The same pseudorandom key will
be used to encrypt all the messages, the resulting key and ciphertexts will be available inside the `keys.txt` and `ciphertexts.txt` files, respectively, both encoded in hexadecimal.

For the following attack to work properly, it's important to write messages containing many space characters (as would any common message) and to write as
many different messages as possible.

## Attacking the Many-Time Pad
Simply run the `manytimepad_attack.py` script, it will try to find the probable plaintext characters of each ciphertext by guessing the position of each
space character for each pair of ciphertexts inside the `ciphertexts.txt` file. It will then print (in the standard output) a list of messages where
each _ represents a character that couldn't be guessed and the other characters are guesses made by the script.

In most cases where the messages are English common phrases and there's a high number of messages (8 or more) with similar lengths, this script is likely
to correctly guess the majority of characters in the plaintexts.
